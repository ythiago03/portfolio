---
title: Tests
description: This is our tests blog posts
date: 2024-10-14
published: true
---

# O que s√£o testes

Existem 3 tipos de testes

- Testes unit√°rios
- Testes de integra√ß√£o
- Testes end-to-end (E2E)

## O que s√£o os testes unit√°rios

Os testes unit√°rios s√£o uma pr√°tica de desenvolvimento de software em que pequenas partes de c√≥digo, chamadas de unidades, s√£o testadas de forma isolada. Essas unidades podem ser fun√ß√µes, m√©todos ou at√© mesmo classes. O objetivo dos testes unit√°rios √© verificar se cada unidade de c√≥digo funciona corretamente e de acordo com as especifica√ß√µes, garantindo a qualidade do software. Eles ajudam a identificar erros e falhas precocemente, facilitando a manuten√ß√£o e evolu√ß√£o do c√≥digo. Al√©m disso, os testes unit√°rios fornecem uma documenta√ß√£o viva do comportamento esperado das unidades de c√≥digo, auxiliando no entendimento e colabora√ß√£o entre os membros da equipe de desenvolvimento.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/94db9d0f-7897-4d99-b9b2-2a2e4a403f6b/Untitled.png)

Um teste √© basicamente composto da maneira acima e seguindo a ordem de cima para baixo, sendo que:

- Primeiro criamos um `teste block`, que basicamente √© a fun√ß√£o que receber√° os nossos testes, como no exemplo:
    
    ```jsx
    test('name of the test', () => {
    
    });
    // o 'test' e o 'it' s√£o exatamente a mesma coisa, mudando somente os nomes.
    it('name of the test', () => {
    
    });
    ```
    
- Despois de criarmos o `test block` precisamos renderizar o componente a ser testado, fazemos isso utilizando a fun√ß√£o `render` do react testing library:
    
    ```jsx
    import App from './App';
    import {render} from '@testing-library/react'
    
    test('name of the test', () => {
    	render(<App/>)
    
    });
    ```
    
- Ap√≥s isso precisamos buscar os elementos a serem testados, a v√°rias formas de fazer isso, uma delas √© utilizando o m√©todo `getByText`, por√©m para utilizarmos ele, precisamos criar uma tela imagin√°ria para conseguirmos capturar o elemento, fazemos isso utilizando o m√©todo `screen`do react testing library como no exemplo:
    
    ```jsx
    import App from './App';
    import {render, screen} from '@testing-library/react'
    
    test('name of the test', () => {
    	render(<App/>)
    	const inputElement = screen.getByText(/learn react/i);
    });
    ```
    
- Feito isso, precisamos interagir com o elemento a ser testado, interagir nada mais √© do que a√ß√µes que podem ser feitas pelo software ou pelo usu√°rio, como um click, uma troca de p√°gina, um envio de formul√°rio entre outras, por√©m n√£o s√£o todos os testes que tem intera√ß√µes, por exemplo, um teste que somente olha se um elemento foi renderizado ou n√£o, n√£o ocorre intera√ß√£o, podemos ver um teste sem e com intera√ß√£o no exemplo:
    
    ```jsx
    import App from './App';
    import {render, screen} from '@testing-library/react'
    
    //Sem intera√ß√£o
    test('name of the test', () => {
    	render(<App/>)
    	const inputElement = screen.getByText(/learn react/i);
    });
    
    //Com intera√ß√£o
    ```
    
    <aside>
    üí° Uma tabela sobre utiliza√ß√£o dos m√©todos de screen:
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/6f579a43-bb94-44a6-a855-1c6e65a6c0ec/Untitled.png)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/c543cffc-f4dc-4ddd-b7bc-eba40473a3da/Untitled.png)
    
    </aside>
    
- Por √∫tilmo por√©m mais importante, √© aqui que n√≥s ‚Äúrealmente testamos‚Äú o que queremos, est√° etapa √© respons√°vel por verificar se a a√ß√£o que fizemos est√° ocorrendo da forma que queremos que ocorra,  para isso utilizamos o `expect` funciton para verificar se tal coisa est√° como o esperado, como no exemplo a seguir:
    
    ```jsx
    import App from './App';
    import {render, screen} from '@testing-library/react'
    
    //Sem intera√ß√£o
    test('name of the test', () => {
    	render(<App/>)
    	const inputElement = screen.getByText(/learn react/i);
    	expect(inputElement).toBeInTheDocument();
    });
    //Aqui estamos testando se o elemento "inputElement" est√° no documento
    ```
    

---

### Mockando  uma depend√™ncia

Neste teste, precisaremos testar uma `div` que cont√©m um elemento `p` e uma `tag link` do React-Router-Dom, para isso, precisaremos criar um ‚ÄúMock‚Äù, mais especificamente, criaremos um ambiente em que seja utiliz√°vel a tag link, pois para utiliza-la precisamos de um BroserRouter do React-Router-Dom, podemos fazer isso da seguinte maneira:

- Criando o mock:

```jsx
import { render, screen } from '@testing-library/react';
import TodoFooter from '../TodoFooter';
import { BrowserRouter } from 'react-router-dom';

const MockTodoFooter = ({numberOfIncompleteTasks}) => {
  return (
    <BrowserRouter>
      <TodoFooter numberOfIncompleteTasks={numberOfIncompleteTasks} />
    </BrowserRouter>
    )
}
```

Feito isso, toda vez que utilizarmos o mock, ele ir√° criar o ambiente prop√≠cio para o nosso componente a ser testado.

- Testando o componente:

```jsx
import { render, screen } from '@testing-library/react';
import TodoFooter from '../TodoFooter';
import { BrowserRouter } from 'react-router-dom';

const MockTodoFooter = ({numberOfIncompleteTasks}) => {
  return (
    <BrowserRouter>
      <TodoFooter numberOfIncompleteTasks={numberOfIncompleteTasks} />
    </BrowserRouter>
    )
}

it('should be in the document', () => {
  render(<MockTodoFooter numberOfIncompleteTasks={5}/>);
  const paragraphElement = screen.getByText(/5 tasks left/i);
  expect(paragraphElement).toBeInTheDocument();
});

it('should render "task" when the number of imcomplete task is one', () => {
  render(<MockTodoFooter numberOfIncompleteTasks={1}/>);
  const paragraphElement = screen.getByText(/1 task left/i);
  expect(paragraphElement).toBeInTheDocument();
});
```

---

### Utilizando o Describe

O describe tem a fun√ß√£o de ajudar na organiza√ß√£o dos testes, podem ter describes filhos ou n√£o, seguido dessa forma:

- Sem describes filhos:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/4054ea1e-033a-457c-961a-c18b98f83267/Untitled.png)

- Com describes filhos:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/d4d1e45c-baa4-48d6-8a47-ffcdeb88cc68/Untitled.png)

Os testes com describe ficam organizados da seguinte maneira:

- Sem describes filhos:

```jsx
import { render, screen } from '@testing-library/react';
import TodoFooter from '../TodoFooter';
import { BrowserRouter } from 'react-router-dom';

const MockTodoFooter = ({numberOfIncompleteTasks}) => {
  return (
    <BrowserRouter>
      <TodoFooter numberOfIncompleteTasks={numberOfIncompleteTasks} />
    </BrowserRouter>
    )
}

describe('TodoFooter', () => {
	it('should be in the document', () => {
	  render(<MockTodoFooter numberOfIncompleteTasks={5}/>);
	  const paragraphElement = screen.getByText(/5 tasks left/i);
	  expect(paragraphElement).toBeInTheDocument();
	});
	
	it('should render "task" when the number of imcomplete task is one', () => {
	  render(<MockTodoFooter numberOfIncompleteTasks={1}/>);
	  const paragraphElement = screen.getByText(/1 task left/i);
	  expect(paragraphElement).toBeInTheDocument();
	});
});
```

- Com describes filhos:

```jsx
import { render, screen } from '@testing-library/react';
import TodoFooter from '../TodoFooter';
import { BrowserRouter } from 'react-router-dom';

const MockTodoFooter = ({numberOfIncompleteTasks}) => {
  return (
    <BrowserRouter>
      <TodoFooter numberOfIncompleteTasks={numberOfIncompleteTasks} />
    </BrowserRouter>
    )
}

describe('TodoFooter', () => {
	
	describe('Functionality 1',() => {
		it('should be in the document', () => {
		  render(<MockTodoFooter numberOfIncompleteTasks={5}/>);
		  const paragraphElement = screen.getByText(/5 tasks left/i);
		  expect(paragraphElement).toBeInTheDocument();
		});
	});
	
	describe('Functionality 2',() => {
		it('should render "task" when the number of imcomplete task is one', () => {
		  render(<MockTodoFooter numberOfIncompleteTasks={1}/>);
		  const paragraphElement = screen.getByText(/1 task left/i);
		  expect(paragraphElement).toBeInTheDocument();
		});
	});
});
```

---

---

## O que √© o vitest

O Vitest √© uma ferramenta de teste de unidade para Node.js que oferece uma abordagem simples e eficiente para escrever e executar testes. Ele permite que os desenvolvedores verifiquem o comportamento esperado das unidades de c√≥digo, garantindo a qualidade e robustez do software. Com o Vitest, √© poss√≠vel testar fun√ß√µes, m√©todos e classes de forma isolada, facilitando a identifica√ß√£o de erros e falhas precocemente. Al√©m disso, o Vitest ajuda a documentar o comportamento esperado das unidades de c√≥digo, promovendo uma melhor colabora√ß√£o entre os membros da equipe de desenvolvimento.

## Como utilizar o Vitest

Para utilizar o Vitest em seu projeto Node.js, siga os passos abaixo:

1. Instale o Vitest, o react testing library e o jest em seu projeto atrav√©s do npm ou yarn:

```
npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom

```

ou

```
yarn add vitest @testing-library/react @testing-library/jest-dom jsdom

```

1. Importe o Vitest, o react testing library e o jest em seu arquivo de teste:

```jsx
import '@testing-library/jest-dom';
import { describe, test } from 'vitest';
```

1. Escreva os testes para suas unidades de c√≥digo utilizando a sintaxe do Vitest. Por exemplo, para testar se um `bot√£o` est√° sendo renderizado, voc√™ pode fazer o seguinte:

```jsx
//All imports here

const buttonTestId = 'idBtnTest';

describe('Button', () => {
  test('Should be able to render the button', () => {
		const { getByTestId } = render(<Button>Click me!</Button>);
		expect(getByTestId(buttonTestId)).toBeInTheDocument();
	})
});

```

1. Execute os testes utilizando o comando adequado para seu ambiente de desenvolvimento. Por exemplo, se estiver utilizando o npm, voc√™ pode usar o seguinte comando:

```
npm test 
//Maybe you need to create the script in the package.json

```

1. Observe os resultados dos testes e verifique se suas unidades de c√≥digo est√£o funcionando corretamente.

Utilizando o Vitest, voc√™ poder√° realizar testes unit√°rios eficientes e garantir a qualidade do seu c√≥digo Node.js**.**