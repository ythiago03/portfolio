---
title: Mysql
description: This is our first blog posts
date: 2024-01-10
published: true
---


O que √© um `DATABASE` ?

> Um banco de dados √© um sistema organizado para armazenar, gerenciar e recuperar dados eletr√¥nicos de maneira eficiente. Ele consiste em tabelas, onde cada linha representa uma entrada e as colunas representam atributos. Bancos de dados s√£o amplamente usados em diversas √°reas para gerenciar grandes volumes de informa√ß√µes, facilitando a organiza√ß√£o e recupera√ß√£o de dados. Sistemas de gerenciamento de banco de dados (SGBD) s√£o usados para facilitar a cria√ß√£o, manuten√ß√£o e consulta desses bancos de dados.
> 

---

### Dados Estruturados e N√£o Estruturados

- **Dados Estruturados:** S√£o dados organizados em uma estrutura predefinida, geralmente em tabelas com linhas e colunas. Cada valor tem um tipo espec√≠fico e segue um esquema predefinido. Bancos de dados relacionais, onde as informa√ß√µes s√£o organizadas em tabelas, s√£o um exemplo comum de dados estruturados.
- **Dados N√£o Estruturados:** S√£o dados que n√£o seguem uma estrutura fixa ou organiza√ß√£o pr√©via. Eles podem incluir texto livre, imagens, v√≠deos e outros formatos que n√£o se encaixam facilmente em uma tabela. Redes sociais, e-mails, documentos em texto livre e m√≠dias s√£o exemplos de dados n√£o estruturados. A an√°lise desses dados geralmente requer m√©todos mais avan√ßados, como processamento de linguagem natural para texto ou reconhecimento de padr√µes para imagens e v√≠deos.

> Em resumo, dados estruturados seguem uma organiza√ß√£o definida, enquanto dados n√£o estruturados carecem dessa organiza√ß√£o predefinida e podem assumir diversas formas. Ambos os tipos de dados s√£o importantes, e a capacidade de lidar com ambos √© fundamental em muitas aplica√ß√µes de an√°lise e tomada de decis√£o.
> 

<aside>
üí° **Para facilitar: Bancos de dados ‚áí Tabelas ‚áí Registros ‚áí Campos**

</aside>

---

## Tipos Primitivos

https://miro.com/app/board/uXjVNKZj8v0=/?moveToWidget=3458764571242631776&cot=14

## Comandos

> O que indica o final de um comando em SQL √© o ‚Äú;‚Äù sendo sempre necess√°rio coloca-lo.
> 

### Criar um database

```sql
CREATE DATABASE nomedodatabase; //Forma simple

CREATE DATABASE nomedodatabase
DEFAULT CHARACTER SET utf8
DEFAULT COLLATE utf8_general_ci; //Forma completa
```

### Criar uma tabela

```sql
CREATE TABLE nomedatabela (
	nome varchar(30),
	idade tinyint(3),
	sexo char(1),
	peso float,
	nacionalidade varchar(20),
);//Forma simple

CREATE TABLE nomedatabela (
	id int not null auto_increment,
	nome varchar(30) not null,
	sexo enum('M','F'),
	peso decimal(5,2),
	altura decimal(3,2),
	nacionalidade varchar(20) default 'Brasil',
	primary key(id)
) DEFAULT CHARSET = utf8;//Forma completa
```

### Deletar tabela ou database

```sql
DROP DATABASE nomedodatabase;
DROP TABLE nomedatabela;
```

### Inserindo dados na tabela

```sql
INSERT INTO nomedatabela
(id, nome, nascimento, sexo, peso, altura, nacionalidade)
VALUES
(DEFAULT, 'Thiago', '2003-01-04', 'M', '59.5', '1.70', 'Brasil');//Forma padr√£o
//A data precisa ser no formato aaaa/mm/dd

INSERT INTO nomedatabela VALUES
(DEFAULT, 'Thiago', '2003-01-04', 'M', '59.5', '1.70', 'Brasil');//Forma simplificada
//(por√©m os dados precisam estar na mesma sequ√™ncia da tabela)

INSERT INTO nomedatabela
(id, nome, nascimento, sexo, peso, altura, nacionalidade)
VALUES
(DEFAULT, 'Emanuelle', '2003-03-22', 'F', '62.3,' '1.62', 'Brasil'),
(DEFAULT, 'Andreza', '2004-04-11', 'F', '55.6', '1.59', 'Brasil'),
(DEFAULT, 'Thiago', '2003-01-04', 'M', '59.5', '1.70', 'Brasil');//Inserindo mais de uma pessoa de uma vez
```

### Descrevendo dados

```sql
DESCRIBE nomedatabela;

DESC nomedatabela;//forma simplificada
```

### Alterando campos tabela

```sql
ALTER TABLE nomedatabela
ADD COLUMN nomedacoluna int;//Adiciona no final da tabela

ALTER TABLE nomedatabela
ADD nomedacoluna int;//Forma simplificada

ALTER TABLE nomedatabela
ADD COLUMN nomedacoluna int FIRST;//Adiciona no in√≠cio da tabela

ALTER TABLE nomedatabela
ADD COLUMN nomedacoluna int AFTER nomedeoutracoluna;//Adiciona ap√≥s a coluna passada

ALTER TABLE nomedatabela
MODIFY COLUMN nomedacoluna varchar(20) not null default '';//O modify reescreve toda a coluna
//ou seja, se voc√™ n√£o passar todas as contraints, ele ir√° deleta-las
//modify n√£o muda o nome da coluna

ALTER TABLE nomedatabela
CHANGE COLUMN nomedacolunaatual nomedanovacoluna varchar(20);//Reescreve toda a coluna
//ou seja, se voc√™ n√£o passar todas as contraints, ele ir√° deleta-las

ALTER TABLE  nomedatabela
CHANGE TO  novonome;//Troca o nome da tabela
```

### Alterando dados da tabela

```sql
UPDATE nomedatabela
SET nomedocampo = 'Thiago', nomedocampo2 = '2003-01-04'
WHERE chaveprimaria = '1'
LIMIT 1;//Comando para alterar dados da tabela, o update recebe a tabela, o set recebe 
// os campos e o que vai receber de altera√ß√£o, o where √© a verifica√ß√£o de onde alterar e o
//limit √© uma seguran√ßa para alterar somente 1 registro

DELETE FROM nomedatabela
WHERE chaveprimaria = '1'
LIMIT 2;//Deleta o(s) registro(s) passado(s) no where

TRUNCATE TABLE nomedatabela;//Deleta TODOS os registros da tabela, mas n√£o deleta a 
//estrutura da tabela
```

### Utilizando o select

```sql
select * from nomedatabela; //Seleciona todos os campos da tabela

select * from nomedatabela order by nome; //Order by ordena pelo par√¢metro passado
//nesse caso, ordena pelo nome em ordem ascendente A-Z, 1-2 

select * from nomedatabela order by nome desc; //Order by ordena pelo par√¢metro passado
//nesse caso, ordena pelo nome em ordem descentente Z-A, 2-1

select * from nomedatabela where id = '13'; //Seleciona tudo que atenda a condi√ß√£o no where
//Pode receber diversos operadores l√≥gicos, os mais comuns s√£o: =, !=, <, >, <=, >=
//Por√©m tamb√©m existem o and, or e o in.

select * from nomedatabela where ano >= '2016' and carga > '40';
select * from nomedatabela where ano >= '2016' or carga > '40';

select * from nomedatabela where nome like 'silva';//O like meio que pega algo que se
//pare√ßa com o par√™metro passado em par√™nteses
select * from nomedatabela where nome not like 'silva';//O not lke √© o contr√°rio do like

//Existem 2 "coringas" para usar no select com like, o "%" e o "_"
//O "%" significa que pode ou n√£o ter algo antes ou depois da palavra, seu uso depende da
//sua localiza√ß√£o

select * from nomedatabela where nome like '%silva';//Ir√° pegar tudo que termine com silva
select * from nomedatabela where nome like '%silva';//Ir√° pegar tudo que come√ße com silva
select * from nomedatabela where nome like '%silva%';//Ir√° pegar tudo que tenha silva em
//qualquer lugar

//O "_" se assemelhar ao "%", por√©m a diferen√ßa √© que obrigatoriamente precisa existir um
//caratere para puxar, o % √© opcional a exist√™ncia desse caractere

select nome, ano from nomedatabela where ano between 2020 and 2024;//Seleciona o que 
//estiver entre os dois valores passados 

select distinct nacionalidade from nomedatabela;//Seleciona mas mostra valores duplicados
//somente 1 vez

select count(*) from nomedatabela;//Conta tudo e retorna o valor

select max(totalaulas) from cursos where ano = '2016';//Retorna o maior valor
select nome, min(totalaulas) from cursos where ano = '2016';//Retorna o menor valor

select sum(totalaulas) from cursos;//Retorna a soma dos valores

select avg(totalaulas) from cursos;//Retorna a m√©dia dos valores

select totalaulas from cursos group by totalaulas;//Funciona de forma parecida do
//distinct por√©m dessa forma conseguimos contar cada grupo

select totalaulas from cursos group by ano having ano > 2016;//Funciona de forma parecida
//do where no select, por√©m s√≥ pode ser passado o mesmo par√¢metro do group by
```

## Relacionamentos, entidades e chaves

### Relacionamentos

Um relacionamento de tabelas √© uma conex√£o estabelecida entre duas ou mais tabelas em um banco de dados relacional. Esses relacionamentos permitem que os dados sejam vinculados e consultados de forma eficiente, permitindo uma melhor organiza√ß√£o e estrutura√ß√£o dos dados.

Existem diferentes tipos de relacionamentos de tabelas, como o relacionamento 1 para 1 e o relacionamento 1 para muitos. No relacionamento 1 para 1, cada registro em uma tabela est√° associado a apenas um registro correspondente na outra tabela. J√° no relacionamento 1 para muitos, um registro em uma tabela pode estar associado a v√°rios registros correspondentes em outra tabela, mas cada registro na segunda tabela est√° associado a apenas um registro na primeira tabela.

Esses relacionamentos s√£o estabelecidos usando chaves prim√°rias e chaves estrangeiras. A chave prim√°ria √© um atributo √∫nico em uma tabela que identifica exclusivamente cada registro. A chave estrangeira √© um atributo em uma tabela que faz refer√™ncia √† chave prim√°ria de outra tabela. Essas chaves s√£o usadas para conectar os dados entre as tabelas, permitindo consultas complexas que combinam informa√ß√µes de v√°rias tabelas.

Os relacionamentos de tabelas s√£o fundamentais para a modelagem de dados em um banco de dados relacional, pois permitem a representa√ß√£o de v√≠nculos entre os dados e a obten√ß√£o de informa√ß√µes mais completas e precisas por meio de consultas.

### Entidades

Um conceito fundamental em SQL √© o de entidades. Em um contexto de bancos de dados, uma entidade representa uma tabela, que √© uma cole√ß√£o de registros relacionados. Cada registro em uma tabela representa uma entrada individual de dados. As entidades s√£o usadas para organizar e armazenar dados de maneira estruturada e eficiente.

No SQL, as entidades s√£o criadas usando o comando CREATE TABLE, onde s√£o definidos os nomes das colunas e os tipos de dados que cada coluna pode armazenar. As entidades tamb√©m podem ser modificadas usando o comando ALTER TABLE, que permite adicionar, modificar ou excluir colunas de uma tabela existente.

As entidades s√£o a base para a cria√ß√£o e manipula√ß√£o de dados em um banco de dados SQL, permitindo a organiza√ß√£o, recupera√ß√£o e an√°lise eficiente dos dados armazenados.

---

### **Atributos SQL**

Em SQL, os atributos s√£o as colunas de uma tabela. Cada atributo corresponde a um tipo de dado espec√≠fico, como texto, n√∫mero, data, entre outros. Os atributos definem a estrutura da tabela e determinam quais tipos de valores podem ser armazenados em cada coluna.

Os atributos t√™m propriedades, como restri√ß√µes de integridade e valores padr√£o. As restri√ß√µes de integridade garantem que os dados inseridos nas colunas estejam dentro de limites espec√≠ficos, como valores m√≠nimos e m√°ximos. Os valores padr√£o especificam um valor predefinido que ser√° inserido automaticamente em uma coluna se nenhum valor for fornecido durante a inser√ß√£o de dados.

Os atributos desempenham um papel fundamental na defini√ß√£o da estrutura e organiza√ß√£o dos dados em um banco de dados SQL. Eles fornecem informa√ß√µes sobre os tipos de dados que podem ser armazenados, as restri√ß√µes aplicadas a esses dados e os relacionamentos entre as tabelas.

---

### Chaves prim√°rias e estrangeiras

Os atributos podem ter chaves prim√°rias e estrangeiras. A chave prim√°ria identifica exclusivamente cada registro em uma tabela e garante a integridade dos dados. As chaves estrangeiras estabelecem relacionamentos entre tabelas, permitindo que os dados sejam conectados e consultados de maneira eficiente.

As tabelas podem ter relacionamentos uns com os outros por meio de chaves estrangeiras, que s√£o colunas que fazem refer√™ncia a uma chave prim√°ria em outra tabela. Esses relacionamentos permitem a cria√ß√£o de consultas complexas que combinam dados de v√°rias tabelas. Os relacionamentos entre entidades s√£o fundamentais para modelar e representar a estrutura e os v√≠nculos dos dados em um banco de dados relacional.

---

### Relacionamento 1 pra 1

Um relacionamento 1 para 1 ocorre quando uma entidade est√° diretamente relacionada a apenas uma outra entidade. Isso significa que cada registro de uma entidade est√° associado a apenas um registro da outra entidade. Em outras palavras, para cada registro em uma tabela, h√° um √∫nico registro correspondente na tabela relacionada. Esse tipo de relacionamento √© √∫til quando h√° uma depend√™ncia direta entre as entidades e √© necess√°rio garantir que cada registro tenha uma correspond√™ncia √∫nica no relacionamento.

### Relacionamento 1 pra N

Um relacionamento 1 para n, ou um relacionamento um para muitos, ocorre quando uma entidade est√° diretamente relacionada a v√°rias inst√¢ncias de outra entidade. Nesse tipo de relacionamento, um registro em uma tabela pode estar associado a v√°rios registros correspondentes em outra tabela, mas cada registro na segunda tabela est√° associado a apenas um registro na primeira tabela. Esse tipo de relacionamento √© comumente utilizado para representar situa√ß√µes em que um √∫nico objeto ou entidade est√° relacionado a v√°rias inst√¢ncias de outra entidade. Por exemplo, um cliente pode ter v√°rias ordens de compra, mas cada ordem de compra est√° vinculada a apenas um cliente. Esse tipo de relacionamento √© fundamental para modelar e representar a estrutura dos dados em bancos de dados relacionais.

### Relacionamento N pra N

Um relacionamento N para N, ou um relacionamento muitos para muitos, ocorre quando uma entidade est√° diretamente relacionada a v√°rias inst√¢ncias de outra entidade e vice-versa. Nesse tipo de relacionamento, v√°rios registros em uma tabela podem estar associados a v√°rios registros correspondentes em outra tabela. Esse tipo de relacionamento √© comumente utilizado para representar situa√ß√µes em que v√°rias entidades est√£o interligadas de forma complexa. Por exemplo, em um sistema de gerenciamento de estudantes e disciplinas, v√°rios estudantes podem se inscrever em v√°rias disciplinas, e cada disciplina pode ter v√°rios estudantes matriculados. Para modelar esse relacionamento, √© necess√°rio criar uma tabela intermedi√°ria que registre as associa√ß√µes entre as entidades, armazenando os identificadores das entidades relacionadas. Esse tipo de relacionamento √© fundamental para representar a estrutura dos dados em bancos de dados relacionais e permite consultas e an√°lises avan√ßadas envolvendo m√∫ltiplas entidades interligadas.

---

## Usando chaves estrangeiras e Joins

### Chaves estrangeiras

Para cadastrar uma chave estrangeira em uma tabela, primeiro precisamos identificar a rela√ß√£o como diz acima, `1 pra 1`, `1 pra N` ou ent√£o `N pra N` , feito isso seguimos as seguintes regras:

- **1 pra 1**
No relacionamento `1 pra 1`, colocamos a chave estrangeira na entidade ‚Äúdominante‚Äù, como no exemplo abaixo:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/59d83e6c-4b90-4b3a-831e-8b0b5240a32a/Untitled.png)

---

- **1 pra N**
No relacionamento `1 pra N`, colocamos a chave estrangeira sempre no lado N, como no exemplo:

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/4c274f5e-ba77-417d-a49c-4f994086cd11/Untitled.png)

---

- **N pra N**
    
    O relacionamento `N pra N` √© um pouco mais complexo, precisamos criar outra entidade entre as duas que estamos relacionando e liga-las com relacionamentos `1 pra n`, seguindo a regra de `1 pra N` , como no exemplo abaixo:
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/1537fed5-cf16-4397-9524-780c2733c432/Untitled.png)
    
    ---
    

**Na pr√°tica, ligamos tabelas com chaves estrangeiras dessa maneira:**

- Primeiro criamos o campo da chave estrangeira na tabela seguindo as regras acima, lembrando que o campo precisa ser da mesma formata√ß√£o, por√©m n√£o precisa ser do mesmo nome.
    
    ```sql
    alter table alunos add column cursopreferido int;
    ```
    
- Logo ap√≥s, configuramos a nova coluna como chave estrangeira.
    
    ```sql
    alter table alunos add foreing key (cursopreferido) references cursos(idcurso);
    //Configurando o campo como chave estrangeira do campo idcurso da tabela cursos.
    ```
    

Feito isso o campo j√° estar√° configurado como uma chave estrangeira!

### Utilizando o Join

O **inner join** e o **outer join** s√£o opera√ß√µes comuns usadas para combinar dados de v√°rias tabelas em consultas SQL.

- **Inner Join**
    
    O **inner join** √© usado para retornar apenas os registros que t√™m correspond√™ncia em ambas as tabelas envolvidas na jun√ß√£o. Ele combina os registros com base em uma condi√ß√£o de correspond√™ncia especificada na cl√°usula **ON**. A consulta resultante incluir√° apenas os registros que satisfazem a condi√ß√£o de jun√ß√£o. Por exemplo, se tivermos uma tabela de "clientes" e uma tabela de "pedidos", um inner join entre elas retornaria apenas os clientes que fizeram pedidos.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/ab6b3bbe-8acd-41d4-99a3-1d9f7ba0669b/Untitled.png)
    
    Para utiliza-lo fazemos o seguinte comando:
    
    ```sql
    select g.nome, g.cursopreferido, c.nome, c.ano 
    from gafanhotos as g inner join cursos as c
    on c.idcurso = g.cursopreferido;
    //Basicamente retorna os dados que tiverem rela√ß√£o, ou seja, s√≥ ir√° mostrar os
    //gafanhotos que tiverem um curso preferido.
    ```
    
    <aside>
    üí° O ‚Äúas‚Äù √© utilizado para ‚Äúapelidar‚Äù uma tabela, assim facilitando na hora de escrever.
    
    </aside>
    
    ---
    
- **Outer Join**
    
    O **outer join** √© usado para retornar todos os registros de uma tabela, mesmo que n√£o haja correspond√™ncia na tabela relacionada. Existem tr√™s tipos de outer join: **left outer join**, **right outer join** e **full outer join**. O left outer join retorna todos os registros da tabela da esquerda e os registros correspondentes da tabela da direita. O right outer join retorna todos os registros da tabela da direita e os registros correspondentes da tabela da esquerda. O full outer join retorna todos os registros de ambas as tabelas, incluindo os registros que n√£o t√™m correspond√™ncia na tabela relacionada.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4bafa185-55e4-4411-ac06-0ada7accd003/cfb266f7-68da-4bca-ac3a-3fdef7fa6b88/Untitled.png)
    
    Para utiliza-lo fazemos o seguinte comando:
    
    ```sql
    select g.nome, g.cursopreferido, c.nome, c.ano 
    from gafanhotos as g left outer join cursos as c
    on c.idcurso = g.cursopreferido;
    //Retorna todos os dados da tabela direcionada(left, righ, full) + as rela√ß√µes da
    //outra tabela.
    ```
    

<aside>
üí° Tanto no inner join como no outer join, as palavras inner e outer s√£o opcionais, por√©m no outer join, precisa-se referenciar qual outer join √©, left, right ou full.

</aside>

A utiliza√ß√£o dessas opera√ß√µes de jun√ß√£o permite combinar dados de v√°rias tabelas em consultas SQL, fornecendo informa√ß√µes mais completas e precisas para an√°lise e tomada de decis√£o.

- **Para relacionamentos `N pra N`**
Primeiro criamos uma tabela ligando as chaves prim√°rias de ambas as tabelas:
    
    ```sql
    create table colaborador_assiste_curso (
    	id int not null auto_increment,
        data date,
        idcolaborador int,
        idcurso int,
        primary key (id),
        foreign key (idcolaborador) references colaboradores(id),
        foreign key (idcurso) references cursos(idcurso)
    ) default charset = utf8;
    ```
    
    Depois, utilizamos um join seguido do outro para ligar os dados de ambas as tr√™s tabelas: